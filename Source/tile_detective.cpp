/**
 * @file tile_detective.cpp
 * @brief Nightmare Edition - Tile Detective Implementation
 * 
 * IMPLEMENTACIÃ“N DEL DETECTIVE DE TILES
 * ====================================
 * 
 * Sistema que permite caminar por el arroyo y capturar automÃ¡ticamente
 * los tile IDs exactos usando los datos reales del mapa.
 */

#include "tile_detective.h"

#include <iostream>
#include <fstream>

#include "utils/log.hpp"
#include "diablo.h"
#include "levels/gendung.h"
#include "player.h"

namespace devilution {

// Estado global del sistema detective
TileDetectiveState tileDetective;

void InitTileDetective()
{
	LogVerbose("Initializing Nightmare Tile Detective System");
	
	tileDetective.enabled = true;
	tileDetective.captureMode = false;
	tileDetective.detectedTiles.clear();
	tileDetective.captureRadius = 1; // Radio de 1 tile alrededor del jugador
	
	LogVerbose("Tile Detective initialized - Ready for water detection");
}

void SetTileDetectiveCapture(bool enabled)
{
	tileDetective.captureMode = enabled;
	
	if (enabled) {
		LogVerbose("ðŸ” TILE DETECTIVE: Capture mode ACTIVATED - PRECISION MODE");
		LogVerbose("Walk EXACTLY through the stream water to capture precise tile IDs");
		LogVerbose("Only tiles directly under your feet will be captured");
		LogVerbose("Press 'T' to toggle capture, 'E' to export results");
		
		// Limpiar detecciones previas para empezar fresh
		ClearDetectedTiles();
	} else {
		LogVerbose("ðŸ” TILE DETECTIVE: Capture mode DEACTIVATED");
		LogVerbose("Captured {} unique tile IDs", tileDetective.detectedTiles.size());
	}
}

void LogTileAtPosition(uint16_t tileId, int x, int y)
{
	if (!tileDetective.enabled || !tileDetective.captureMode) {
		return;
	}
	
	// Solo capturar en el town
	if (leveltype != DTYPE_TOWN) {
		return;
	}
	
	// Agregar tile a la lista de detectados
	if (tileDetective.detectedTiles.find(tileId) == tileDetective.detectedTiles.end()) {
		tileDetective.detectedTiles.insert(tileId);
		LogVerbose("ðŸŒŠ WATER TILE DETECTED: ID {} at position ({}, {})", tileId, x, y);
	}
}

/**
 * @brief Captura tiles alrededor de la posiciÃ³n del jugador - MODO PRECISIÃ“N
 */
void CapturePlayerSurroundingTiles()
{
	if (!tileDetective.enabled || !tileDetective.captureMode || leveltype != DTYPE_TOWN) {
		return;
	}
	
	if (MyPlayer == nullptr) {
		return;
	}
	
	Point playerPos = MyPlayer->position.tile;
	
	// ðŸŽ¯ MODO PRECISIÃ“N: Solo capturar el tile exacto bajo el jugador
	// No capturar Ã¡rea amplia, solo el tile especÃ­fico donde estÃ¡ parado
	int x = playerPos.x;
	int y = playerPos.y;
	
	// Verificar lÃ­mites del mapa
	if (x >= 0 && x < MAXDUNX && y >= 0 && y < MAXDUNY) {
		// Obtener el tile ID desde dPiece
		uint16_t tileId = dPiece[x][y];
		if (tileId != 0) {
			LogTileAtPosition(tileId, x, y);
		}
	}
	
	// ðŸ”§ OPCIONAL: Capturar tambiÃ©n tiles inmediatamente adyacentes (radio 0)
	// Solo si queremos un poco mÃ¡s de contexto, pero manteniendo precisiÃ³n
	/*
	for (int dx = -1; dx <= 1; dx++) {
		for (int dy = -1; dy <= 1; dy++) {
			if (dx == 0 && dy == 0) continue; // Ya capturamos el centro
			
			int adjX = playerPos.x + dx;
			int adjY = playerPos.y + dy;
			
			if (adjX >= 0 && adjX < MAXDUNX && adjY >= 0 && adjY < MAXDUNY) {
				uint16_t adjTileId = dPiece[adjX][adjY];
				if (adjTileId != 0) {
					LogTileAtPosition(adjTileId, adjX, adjY);
				}
			}
		}
	}
	*/
}

bool IsDetectedWaterTile(uint16_t tileId)
{
	return tileDetective.detectedTiles.find(tileId) != tileDetective.detectedTiles.end();
}

void ExportDetectedTiles()
{
	if (tileDetective.detectedTiles.empty()) {
		LogVerbose("No tiles detected yet. Walk through the stream first!");
		return;
	}
	
	// Exportar a archivo para anÃ¡lisis
	std::ofstream file("detected_water_tiles.txt");
	if (file.is_open()) {
		file << "// Nightmare Edition - Detected Water Tile IDs\n";
		file << "// Generated by Tile Detective System\n";
		file << "// Total tiles detected: " << tileDetective.detectedTiles.size() << "\n\n";
		
		file << "bool IsTownWaterTile(uint16_t tileId) {\n";
		file << "    switch (tileId) {\n";
		
		for (uint16_t tileId : tileDetective.detectedTiles) {
			file << "        case " << tileId << ":\n";
		}
		
		file << "            return true;\n";
		file << "        default:\n";
		file << "            return false;\n";
		file << "    }\n";
		file << "}\n";
		
		file.close();
		LogVerbose("ðŸŽ¯ Detected tiles exported to: detected_water_tiles.txt");
	}
	
	// TambiÃ©n log en consola
	LogVerbose("ðŸŒŠ DETECTED WATER TILES:");
	for (uint16_t tileId : tileDetective.detectedTiles) {
		LogVerbose("  - Tile ID: {}", tileId);
	}
}

void ClearDetectedTiles()
{
	tileDetective.detectedTiles.clear();
	LogVerbose("ðŸ§¹ Detected tiles cleared");
}

/**
 * @brief Actualiza el sistema detective (llamar desde GameLogic)
 */
void UpdateTileDetective()
{
	if (tileDetective.enabled && tileDetective.captureMode) {
		CapturePlayerSurroundingTiles();
	}
}

} // namespace devilution