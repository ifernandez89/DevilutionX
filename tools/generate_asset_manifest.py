#!/usr/bin/env python3
"""
Asset Manifest Generator for Nightmare Browser Edition

This tool scans the codebase for asset file references and generates
a manifest for embedding assets in WebAssembly builds.

Usage:
    python tools/generate_asset_manifest.py
"""

import os
import re
import json
from pathlib import Path
from typing import Set, Dict, List

class AssetManifestGenerator:
    def __init__(self, source_dir: str = "Source", assets_dir: str = "assets"):
        self.source_dir = Path(source_dir)
        self.assets_dir = Path(assets_dir)
        self.found_assets: Set[str] = set()
        
    def scan_source_files(self) -> None:
        """Scan all C++ source files for asset references"""
        print("ğŸ” Scanning source files for asset references...")
        
        # Patterns to match asset file references
        patterns = [
            r'"([^"]+\.(?:dun|trn|pal|cel|clx|wav|mpq))"',  # Quoted file paths
            r"'([^']+\.(?:dun|trn|pal|cel|clx|wav|mpq))'",  # Single quoted paths
            r'R"\(([^)]+\.(?:dun|trn|pal|cel|clx|wav|mpq))\)"',  # Raw string literals
        ]
        
        for cpp_file in self.source_dir.rglob("*.cpp"):
            self._scan_file(cpp_file, patterns)
            
        for h_file in self.source_dir.rglob("*.h"):
            self._scan_file(h_file, patterns)
            
        print(f"âœ… Found {len(self.found_assets)} unique asset references")
        
    def _scan_file(self, file_path: Path, patterns: List[str]) -> None:
        """Scan a single file for asset patterns"""
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
                
            for pattern in patterns:
                matches = re.findall(pattern, content, re.IGNORECASE)
                for match in matches:
                    # Normalize path separators
                    normalized_path = match.replace('\\', '/')
                    self.found_assets.add(normalized_path)
                    
        except Exception as e:
            print(f"âš ï¸ Warning: Could not scan {file_path}: {e}")
            
    def verify_assets_exist(self) -> Dict[str, bool]:
        """Verify which assets actually exist in the assets directory"""
        print("ğŸ“ Verifying asset existence...")
        
        asset_status = {}
        existing_count = 0
        
        for asset_path in sorted(self.found_assets):
            full_path = self.assets_dir / asset_path
            exists = full_path.exists()
            asset_status[asset_path] = exists
            
            if exists:
                existing_count += 1
                print(f"âœ… {asset_path}")
            else:
                print(f"âŒ {asset_path} (NOT FOUND)")
                
        print(f"ğŸ“Š Asset Status: {existing_count}/{len(self.found_assets)} assets found")
        return asset_status
        
    def generate_cpp_manifest(self, output_file: str = "Source/platform/web/asset_manifest.cpp") -> None:
        """Generate C++ code for asset manifest"""
        print(f"ğŸ”§ Generating C++ manifest: {output_file}")
        
        # Verify assets first
        asset_status = self.verify_assets_exist()
        existing_assets = [path for path, exists in asset_status.items() if exists]
        
        cpp_content = self._generate_cpp_content(existing_assets)
        
        os.makedirs(os.path.dirname(output_file), exist_ok=True)
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(cpp_content)
            
        print(f"âœ… Generated manifest with {len(existing_assets)} assets")
        
    def _generate_cpp_content(self, assets: List[str]) -> str:
        """Generate the actual C++ content for the manifest"""
        header = '''/**
 * @file asset_manifest.cpp
 * @brief Auto-generated asset manifest for WebAssembly builds
 * 
 * This file is automatically generated by tools/generate_asset_manifest.py
 * DO NOT EDIT MANUALLY - your changes will be overwritten!
 */

#include "embedded_vfs.h"

namespace devilution {

// Forward declarations for embedded asset data
'''
        
        # Generate forward declarations
        declarations = []
        for asset_path in assets:
            var_name = self._path_to_variable_name(asset_path)
            declarations.append(f"extern const uint8_t {var_name}_data[];")
            declarations.append(f"extern const size_t {var_name}_size;")
            
        # Generate registration function
        registration_func = '''
void EmbeddedVFS::RegisterAssetsFromManifest()
{{
    LogInfo("ğŸŒ Registering {{}} embedded assets for WebAssembly...", {});
    
'''.format(len(assets))

        for asset_path in assets:
            var_name = self._path_to_variable_name(asset_path)
            registration_func += f'    RegisterAsset("{asset_path}", {var_name}_data, {var_name}_size);\n'
            
        registration_func += '''
    LogInfo("âœ… Asset registration complete: {{}} assets ready", assets.size());
}

} // namespace devilution'''

        return header + '\n'.join(declarations) + registration_func
        
    def _path_to_variable_name(self, path: str) -> str:
        """Convert asset path to valid C++ variable name"""
        # Replace path separators and special characters
        var_name = path.replace('/', '_').replace('\\', '_')
        var_name = re.sub(r'[^a-zA-Z0-9_]', '_', var_name)
        var_name = re.sub(r'_+', '_', var_name)  # Collapse multiple underscores
        var_name = var_name.strip('_')  # Remove leading/trailing underscores
        
        return f"asset_{var_name}"
        
    def generate_json_manifest(self, output_file: str = "asset_manifest.json") -> None:
        """Generate JSON manifest for build tools"""
        print(f"ğŸ“„ Generating JSON manifest: {output_file}")
        
        asset_status = self.verify_assets_exist()
        
        manifest = {
            "version": "1.0.0",
            "generated_by": "generate_asset_manifest.py",
            "total_assets": len(self.found_assets),
            "existing_assets": len([exists for exists in asset_status.values() if exists]),
            "assets": {
                "existing": [path for path, exists in asset_status.items() if exists],
                "missing": [path for path, exists in asset_status.items() if not exists]
            }
        }
        
        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(manifest, f, indent=2, sort_keys=True)
            
        print(f"âœ… JSON manifest generated")

def main():
    print("ğŸŒ Nightmare Browser Edition - Asset Manifest Generator")
    print("=" * 60)
    
    generator = AssetManifestGenerator()
    
    # Scan source files for asset references
    generator.scan_source_files()
    
    # Generate C++ manifest
    generator.generate_cpp_manifest()
    
    # Generate JSON manifest for reference
    generator.generate_json_manifest()
    
    print("\nğŸ¯ Asset manifest generation complete!")
    print("Next steps:")
    print("1. Review the generated manifest files")
    print("2. Use Emscripten's --embed-file to embed assets")
    print("3. Compile with WebAssembly target")

if __name__ == "__main__":
    main()